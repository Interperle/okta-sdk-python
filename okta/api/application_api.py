# coding: utf-8

"""
    Okta API

    Allows customers to easily access the Okta API  # noqa: E501

    OpenAPI spec version: 2.9.2
    Contact: devex-public@okta.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from okta.swagger_api_client import ApiClient


class Application(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def activate_application(self, app_id, **kwargs):  # noqa: E501
        """Activate Application  # noqa: E501

        Activates an inactive application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.activate_application(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.activate_application_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.activate_application_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def activate_application_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """Activate Application  # noqa: E501

        Activates an inactive application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.activate_application_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method activate_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `activate_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/lifecycle/activate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def assign_user_to_application(self, app_id, body, **kwargs):  # noqa: E501
        """Assign User to Application for SSO & Provisioning  # noqa: E501

        Assigns an user to an application with [credentials](#application-user-credentials-object) and an app-specific [profile](#application-user-profile-object). Profile mappings defined for the application are first applied before applying any profile properties specified in the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_user_to_application(app_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param AppUser body: (required)
        :return: AppUser
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.assign_user_to_application_with_http_info(app_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.assign_user_to_application_with_http_info(app_id, body, **kwargs)  # noqa: E501
            return data

    def assign_user_to_application_with_http_info(self, app_id, body, **kwargs):  # noqa: E501
        """Assign User to Application for SSO & Provisioning  # noqa: E501

        Assigns an user to an application with [credentials](#application-user-credentials-object) and an app-specific [profile](#application-user-profile-object). Profile mappings defined for the application are first applied before applying any profile properties specified in the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_user_to_application_with_http_info(app_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param AppUser body: (required)
        :return: AppUser
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id''body', ]  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assign_user_to_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `assign_user_to_application`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `assign_user_to_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppUser',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clone_application_key(self, app_id, key_id, target_aid, **kwargs):  # noqa: E501
        """Clone Application Key Credential  # noqa: E501

        Clones a X.509 certificate for an application key credential from a source application to target application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_application_key(app_id, key_id, target_aid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str key_id: (required)
        :param str target_aid: Unique key of the target Application (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.clone_application_key_with_http_info(app_id, key_id, target_aid, **kwargs)  # noqa: E501
        else:
            (data) = self.clone_application_key_with_http_info(app_id, key_id, target_aid, **kwargs)  # noqa: E501
            return data

    def clone_application_key_with_http_info(self, app_id, key_id, target_aid, **kwargs):  # noqa: E501
        """Clone Application Key Credential  # noqa: E501

        Clones a X.509 certificate for an application key credential from a source application to target application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_application_key_with_http_info(app_id, key_id, target_aid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str key_id: (required)
        :param str target_aid: Unique key of the target Application (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'key_id', 'target_aid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clone_application_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `clone_application_key`")  # noqa: E501
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params or
                params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `clone_application_key`")  # noqa: E501
        # verify the required parameter 'target_aid' is set
        if ('target_aid' not in params or
                params['target_aid'] is None):
            raise ValueError("Missing the required parameter `target_aid` when calling `clone_application_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'key_id' in params:
            path_params['keyId'] = params['key_id']  # noqa: E501

        query_params = []
        if 'target_aid' in params:
            query_params.append(('targetAid', params['target_aid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/keys/{keyId}/clone', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonWebKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_application(self, body, **kwargs):  # noqa: E501
        """Add Application  # noqa: E501

        Adds a new application to your Okta organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Application body: (required)
        :param str okta_access_gateway_agent:
        :param bool activate: Executes activation lifecycle operation when creating the app
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_application_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_application_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_application_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add Application  # noqa: E501

        Adds a new application to your Okta organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Application body: (required)
        :param str okta_access_gateway_agent:
        :param bool activate: Executes activation lifecycle operation when creating the app
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'okta_access_gateway_agent', 'activate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'activate' in params:
            query_params.append(('activate', params['activate']))  # noqa: E501

        header_params = {}
        if 'okta_access_gateway_agent' in params:
            header_params['OktaAccessGateway-Agent'] = params['okta_access_gateway_agent']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_application_group_assignment(self, app_id, group_id, **kwargs):  # noqa: E501
        """Assign Group to Application  # noqa: E501

        Assigns a group to an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_group_assignment(app_id, group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str group_id: (required)
        :param ApplicationGroupAssignment body:
        :return: ApplicationGroupAssignment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_application_group_assignment_with_http_info(app_id, group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_application_group_assignment_with_http_info(app_id, group_id, **kwargs)  # noqa: E501
            return data

    def create_application_group_assignment_with_http_info(self, app_id, group_id, **kwargs):  # noqa: E501
        """Assign Group to Application  # noqa: E501

        Assigns a group to an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_group_assignment_with_http_info(app_id, group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str group_id: (required)
        :param ApplicationGroupAssignment body:
        :return: ApplicationGroupAssignment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'group_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_application_group_assignment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `create_application_group_assignment`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `create_application_group_assignment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'group_id' in params:
            path_params['groupId'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/groups/{groupId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationGroupAssignment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deactivate_application(self, app_id, **kwargs):  # noqa: E501
        """Deactivate Application  # noqa: E501

        Deactivates an active application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deactivate_application(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.deactivate_application_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.deactivate_application_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def deactivate_application_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """Deactivate Application  # noqa: E501

        Deactivates an active application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deactivate_application_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deactivate_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `deactivate_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/lifecycle/deactivate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_application(self, app_id, **kwargs):  # noqa: E501
        """Delete Application  # noqa: E501

        Removes an inactive application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_application_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_application_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def delete_application_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """Delete Application  # noqa: E501

        Removes an inactive application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `delete_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_application_group_assignment(self, app_id, group_id, **kwargs):  # noqa: E501
        """Remove Group from Application  # noqa: E501

        Removes a group assignment from an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_group_assignment(app_id, group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str group_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_application_group_assignment_with_http_info(app_id, group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_application_group_assignment_with_http_info(app_id, group_id, **kwargs)  # noqa: E501
            return data

    def delete_application_group_assignment_with_http_info(self, app_id, group_id, **kwargs):  # noqa: E501
        """Remove Group from Application  # noqa: E501

        Removes a group assignment from an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_group_assignment_with_http_info(app_id, group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str group_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_application_group_assignment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `delete_application_group_assignment`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `delete_application_group_assignment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'group_id' in params:
            path_params['groupId'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/groups/{groupId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_application_user(self, app_id, user_id, **kwargs):  # noqa: E501
        """Remove User from Application  # noqa: E501

        Removes an assignment for a user from an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_user(app_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str user_id: (required)
        :param bool send_email:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_application_user_with_http_info(app_id, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_application_user_with_http_info(app_id, user_id, **kwargs)  # noqa: E501
            return data

    def delete_application_user_with_http_info(self, app_id, user_id, **kwargs):  # noqa: E501
        """Remove User from Application  # noqa: E501

        Removes an assignment for a user from an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_user_with_http_info(app_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str user_id: (required)
        :param bool send_email:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'user_id', 'send_email']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_application_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `delete_application_user`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_application_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'send_email' in params:
            query_params.append(('sendEmail', params['send_email']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/users/{userId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_application_key(self, app_id, **kwargs):  # noqa: E501
        """generate_application_key  # noqa: E501

        Generates a new X.509 certificate for an application key credential  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_application_key(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int validity_years:
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.generate_application_key_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_application_key_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def generate_application_key_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """generate_application_key  # noqa: E501

        Generates a new X.509 certificate for an application key credential  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_application_key_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int validity_years:
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'validity_years']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_application_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `generate_application_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []
        if 'validity_years' in params:
            query_params.append(('validityYears', params['validity_years']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/keys/generate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonWebKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_csr_for_application(self, app_id, body, **kwargs):  # noqa: E501
        """Generate Certificate Signing Request for Application  # noqa: E501

        Generates a new key pair and returns the Certificate Signing Request for it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_csr_for_application(app_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param CsrMetadata body: (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.generate_csr_for_application_with_http_info(app_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_csr_for_application_with_http_info(app_id, body, **kwargs)  # noqa: E501
            return data

    def generate_csr_for_application_with_http_info(self, app_id, body, **kwargs):  # noqa: E501
        """Generate Certificate Signing Request for Application  # noqa: E501

        Generates a new key pair and returns the Certificate Signing Request for it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_csr_for_application_with_http_info(app_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param CsrMetadata body: (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id''body', ]  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_csr_for_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `generate_csr_for_application`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `generate_csr_for_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/csrs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Csr',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application(self, app_id, **kwargs):  # noqa: E501
        """Get Application  # noqa: E501

        Fetches an application from your Okta organization by `id`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str expand:
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def get_application_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """Get Application  # noqa: E501

        Fetches an application from your Okta organization by `id`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str expand:
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_group_assignment(self, app_id, group_id, **kwargs):  # noqa: E501
        """Get Assigned Group for Application  # noqa: E501

        Fetches an application group assignment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_group_assignment(app_id, group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str group_id: (required)
        :param str expand:
        :return: ApplicationGroupAssignment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_group_assignment_with_http_info(app_id, group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_group_assignment_with_http_info(app_id, group_id, **kwargs)  # noqa: E501
            return data

    def get_application_group_assignment_with_http_info(self, app_id, group_id, **kwargs):  # noqa: E501
        """Get Assigned Group for Application  # noqa: E501

        Fetches an application group assignment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_group_assignment_with_http_info(app_id, group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str group_id: (required)
        :param str expand:
        :return: ApplicationGroupAssignment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'group_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_group_assignment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_application_group_assignment`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `get_application_group_assignment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'group_id' in params:
            path_params['groupId'] = params['group_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/groups/{groupId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationGroupAssignment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_key(self, app_id, key_id, **kwargs):  # noqa: E501
        """Get Key Credential for Application  # noqa: E501

        Gets a specific application key credential by kid  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_key(app_id, key_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str key_id: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_key_with_http_info(app_id, key_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_key_with_http_info(app_id, key_id, **kwargs)  # noqa: E501
            return data

    def get_application_key_with_http_info(self, app_id, key_id, **kwargs):  # noqa: E501
        """Get Key Credential for Application  # noqa: E501

        Gets a specific application key credential by kid  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_key_with_http_info(app_id, key_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str key_id: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'key_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_application_key`")  # noqa: E501
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params or
                params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `get_application_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'key_id' in params:
            path_params['keyId'] = params['key_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/keys/{keyId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonWebKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_user(self, app_id, user_id, **kwargs):  # noqa: E501
        """Get Assigned User for Application  # noqa: E501

        Fetches a specific user assignment for application by `id`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_user(app_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str user_id: (required)
        :param str expand:
        :return: AppUser
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_user_with_http_info(app_id, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_user_with_http_info(app_id, user_id, **kwargs)  # noqa: E501
            return data

    def get_application_user_with_http_info(self, app_id, user_id, **kwargs):  # noqa: E501
        """Get Assigned User for Application  # noqa: E501

        Fetches a specific user assignment for application by `id`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_user_with_http_info(app_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str user_id: (required)
        :param str expand:
        :return: AppUser
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'user_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_application_user`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_application_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/users/{userId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppUser',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_csr_for_application(self, app_id, csr_id, **kwargs):  # noqa: E501
        """Get Certificate Signing Request  # noqa: E501

        Fetches a certificate signing request for the app by `id`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_csr_for_application(app_id, csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_csr_for_application_with_http_info(app_id, csr_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_csr_for_application_with_http_info(app_id, csr_id, **kwargs)  # noqa: E501
            return data

    def get_csr_for_application_with_http_info(self, app_id, csr_id, **kwargs):  # noqa: E501
        """Get Certificate Signing Request  # noqa: E501

        Fetches a certificate signing request for the app by `id`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_csr_for_application_with_http_info(app_id, csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'csr_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_csr_for_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_csr_for_application`")  # noqa: E501
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `get_csr_for_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'csr_id' in params:
            path_params['csrId'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/csrs/{csrId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Csr',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_o_auth2_token_for_application(self, app_id, token_id, **kwargs):  # noqa: E501
        """get_o_auth2_token_for_application  # noqa: E501

        Gets a token for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_o_auth2_token_for_application(app_id, token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str token_id: (required)
        :param str expand:
        :return: OAuth2Token
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_o_auth2_token_for_application_with_http_info(app_id, token_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_o_auth2_token_for_application_with_http_info(app_id, token_id, **kwargs)  # noqa: E501
            return data

    def get_o_auth2_token_for_application_with_http_info(self, app_id, token_id, **kwargs):  # noqa: E501
        """get_o_auth2_token_for_application  # noqa: E501

        Gets a token for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_o_auth2_token_for_application_with_http_info(app_id, token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str token_id: (required)
        :param str expand:
        :return: OAuth2Token
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'token_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_o_auth2_token_for_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_o_auth2_token_for_application`")  # noqa: E501
        # verify the required parameter 'token_id' is set
        if ('token_id' not in params or
                params['token_id'] is None):
            raise ValueError("Missing the required parameter `token_id` when calling `get_o_auth2_token_for_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'token_id' in params:
            path_params['tokenId'] = params['token_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/tokens/{tokenId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OAuth2Token',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_scope_consent_grant(self, app_id, grant_id, **kwargs):  # noqa: E501
        """get_scope_consent_grant  # noqa: E501

        Fetches a single scope consent grant for the application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scope_consent_grant(app_id, grant_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str grant_id: (required)
        :param str expand:
        :return: OAuth2ScopeConsentGrant
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_scope_consent_grant_with_http_info(app_id, grant_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_scope_consent_grant_with_http_info(app_id, grant_id, **kwargs)  # noqa: E501
            return data

    def get_scope_consent_grant_with_http_info(self, app_id, grant_id, **kwargs):  # noqa: E501
        """get_scope_consent_grant  # noqa: E501

        Fetches a single scope consent grant for the application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scope_consent_grant_with_http_info(app_id, grant_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str grant_id: (required)
        :param str expand:
        :return: OAuth2ScopeConsentGrant
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'grant_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scope_consent_grant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_scope_consent_grant`")  # noqa: E501
        # verify the required parameter 'grant_id' is set
        if ('grant_id' not in params or
                params['grant_id'] is None):
            raise ValueError("Missing the required parameter `grant_id` when calling `get_scope_consent_grant`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'grant_id' in params:
            path_params['grantId'] = params['grant_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/grants/{grantId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OAuth2ScopeConsentGrant',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def grant_consent_to_scope(self, app_id, body, **kwargs):  # noqa: E501
        """grant_consent_to_scope  # noqa: E501

        Grants consent for the application to request an OAuth 2.0 Okta scope  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.grant_consent_to_scope(app_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param OAuth2ScopeConsentGrant body: (required)
        :return: OAuth2ScopeConsentGrant
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.grant_consent_to_scope_with_http_info(app_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.grant_consent_to_scope_with_http_info(app_id, body, **kwargs)  # noqa: E501
            return data

    def grant_consent_to_scope_with_http_info(self, app_id, body, **kwargs):  # noqa: E501
        """grant_consent_to_scope  # noqa: E501

        Grants consent for the application to request an OAuth 2.0 Okta scope  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.grant_consent_to_scope_with_http_info(app_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param OAuth2ScopeConsentGrant body: (required)
        :return: OAuth2ScopeConsentGrant
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id''body', ]  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method grant_consent_to_scope" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `grant_consent_to_scope`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `grant_consent_to_scope`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/grants', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OAuth2ScopeConsentGrant',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_application_group_assignments(self, app_id, **kwargs):  # noqa: E501
        """List Groups Assigned to Application  # noqa: E501

        Enumerates group assignments for an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_group_assignments(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str q:
        :param str after: Specifies the pagination cursor for the next page of assignments
        :param int limit: Specifies the number of results for a page
        :param str expand:
        :return: list[ApplicationGroupAssignment]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_application_group_assignments_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_application_group_assignments_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def list_application_group_assignments_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """List Groups Assigned to Application  # noqa: E501

        Enumerates group assignments for an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_group_assignments_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str q:
        :param str after: Specifies the pagination cursor for the next page of assignments
        :param int limit: Specifies the number of results for a page
        :param str expand:
        :return: list[ApplicationGroupAssignment]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'q', 'after', 'limit', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_application_group_assignments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `list_application_group_assignments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ApplicationGroupAssignment]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_application_keys(self, app_id, **kwargs):  # noqa: E501
        """List Key Credentials for Application  # noqa: E501

        Enumerates key credentials for an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_keys(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: list[JsonWebKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_application_keys_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_application_keys_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def list_application_keys_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """List Key Credentials for Application  # noqa: E501

        Enumerates key credentials for an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_keys_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: list[JsonWebKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_application_keys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `list_application_keys`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[JsonWebKey]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_application_users(self, app_id, **kwargs):  # noqa: E501
        """List Users Assigned to Application  # noqa: E501

        Enumerates all assigned [application users](#application-user-model) for an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_users(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str q:
        :param str query_scope:
        :param str after: specifies the pagination cursor for the next page of assignments
        :param int limit: specifies the number of results for a page
        :param str filter:
        :param str expand:
        :return: list[AppUser]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_application_users_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_application_users_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def list_application_users_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """List Users Assigned to Application  # noqa: E501

        Enumerates all assigned [application users](#application-user-model) for an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_users_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str q:
        :param str query_scope:
        :param str after: specifies the pagination cursor for the next page of assignments
        :param int limit: specifies the number of results for a page
        :param str filter:
        :param str expand:
        :return: list[AppUser]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'q', 'query_scope', 'after', 'limit', 'filter', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_application_users" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `list_application_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'query_scope' in params:
            query_params.append(('query_scope', params['query_scope']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AppUser]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_applications(self, **kwargs):  # noqa: E501
        """List Applications  # noqa: E501

        Enumerates apps added to your organization with pagination. A subset of apps can be returned that match a supported filter expression or query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_applications(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q:
        :param str after: Specifies the pagination cursor for the next page of apps
        :param int limit: Specifies the number of results for a page
        :param str filter: Filters apps by status, user.id, group.id or credentials.signing.kid expression
        :param str expand: Traverses users link relationship and optionally embeds Application User resource
        :param bool include_non_deleted:
        :return: list[Application]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_applications_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_applications_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_applications_with_http_info(self, **kwargs):  # noqa: E501
        """List Applications  # noqa: E501

        Enumerates apps added to your organization with pagination. A subset of apps can be returned that match a supported filter expression or query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_applications_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q:
        :param str after: Specifies the pagination cursor for the next page of apps
        :param int limit: Specifies the number of results for a page
        :param str filter: Filters apps by status, user.id, group.id or credentials.signing.kid expression
        :param str expand: Traverses users link relationship and optionally embeds Application User resource
        :param bool include_non_deleted:
        :return: list[Application]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q', 'after', 'limit', 'filter', 'expand', 'include_non_deleted']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_applications" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
        if 'include_non_deleted' in params:
            query_params.append(('includeNonDeleted', params['include_non_deleted']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Application]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_csrs_for_application(self, app_id, **kwargs):  # noqa: E501
        """List Certificate Signing Requests for Application  # noqa: E501

        Enumerates Certificate Signing Requests for an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_csrs_for_application(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: list[Csr]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_csrs_for_application_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_csrs_for_application_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def list_csrs_for_application_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """List Certificate Signing Requests for Application  # noqa: E501

        Enumerates Certificate Signing Requests for an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_csrs_for_application_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: list[Csr]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_csrs_for_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `list_csrs_for_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/csrs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Csr]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_o_auth2_tokens_for_application(self, app_id, **kwargs):  # noqa: E501
        """list_o_auth2_tokens_for_application  # noqa: E501

        Lists all tokens for the application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_o_auth2_tokens_for_application(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str expand:
        :param str after:
        :param int limit:
        :return: list[OAuth2Token]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_o_auth2_tokens_for_application_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_o_auth2_tokens_for_application_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def list_o_auth2_tokens_for_application_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """list_o_auth2_tokens_for_application  # noqa: E501

        Lists all tokens for the application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_o_auth2_tokens_for_application_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str expand:
        :param str after:
        :param int limit:
        :return: list[OAuth2Token]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'expand', 'after', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_o_auth2_tokens_for_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `list_o_auth2_tokens_for_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/tokens', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OAuth2Token]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_scope_consent_grants(self, app_id, **kwargs):  # noqa: E501
        """list_scope_consent_grants  # noqa: E501

        Lists all scope consent grants for the application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_scope_consent_grants(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str expand:
        :return: list[OAuth2ScopeConsentGrant]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_scope_consent_grants_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_scope_consent_grants_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def list_scope_consent_grants_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """list_scope_consent_grants  # noqa: E501

        Lists all scope consent grants for the application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_scope_consent_grants_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str expand:
        :return: list[OAuth2ScopeConsentGrant]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_scope_consent_grants" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `list_scope_consent_grants`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/grants', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OAuth2ScopeConsentGrant]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_csr_from_application(self, app_id, csr_id, body, **kwargs):  # noqa: E501
        """Publish Certificate Signing Request  # noqa: E501

        Updates a certificate signing request for the app with a signed X.509 certificate and adds it into the application key credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_csr_from_application(app_id, csr_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :param Object body: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.publish_csr_from_application_with_http_info(app_id, csr_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.publish_csr_from_application_with_http_info(app_id, csr_id, body, **kwargs)  # noqa: E501
            return data

    def publish_csr_from_application_with_http_info(self, app_id, csr_id, body, **kwargs):  # noqa: E501
        """Publish Certificate Signing Request  # noqa: E501

        Updates a certificate signing request for the app with a signed X.509 certificate and adds it into the application key credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_csr_from_application_with_http_info(app_id, csr_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :param Object body: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'csr_id''body', ]  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_csr_from_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `publish_csr_from_application`")  # noqa: E501
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `publish_csr_from_application`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `publish_csr_from_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'csr_id' in params:
            path_params['csrId'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream', 'application/x-x509-ca-cert', 'application/pkix-cert', 'application/x-pem-file'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/csrs/{csrId}/lifecycle/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonWebKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_csr_from_application(self, app_id, csr_id, body, **kwargs):  # noqa: E501
        """Publish Certificate Signing Request  # noqa: E501

        Updates a certificate signing request for the app with a signed X.509 certificate and adds it into the application key credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_csr_from_application(app_id, csr_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :param Object body: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.publish_csr_from_application_with_http_info(app_id, csr_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.publish_csr_from_application_with_http_info(app_id, csr_id, body, **kwargs)  # noqa: E501
            return data

    def publish_csr_from_application_with_http_info(self, app_id, csr_id, body, **kwargs):  # noqa: E501
        """Publish Certificate Signing Request  # noqa: E501

        Updates a certificate signing request for the app with a signed X.509 certificate and adds it into the application key credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_csr_from_application_with_http_info(app_id, csr_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :param Object body: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'csr_id''body', ]  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_csr_from_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `publish_csr_from_application`")  # noqa: E501
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `publish_csr_from_application`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `publish_csr_from_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'csr_id' in params:
            path_params['csrId'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream', 'application/x-x509-ca-cert', 'application/pkix-cert', 'application/x-pem-file'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/csrs/{csrId}/lifecycle/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonWebKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_csr_from_application(self, app_id, csr_id, body, **kwargs):  # noqa: E501
        """Publish Certificate Signing Request  # noqa: E501

        Updates a certificate signing request for the app with a signed X.509 certificate and adds it into the application key credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_csr_from_application(app_id, csr_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :param Object body: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.publish_csr_from_application_with_http_info(app_id, csr_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.publish_csr_from_application_with_http_info(app_id, csr_id, body, **kwargs)  # noqa: E501
            return data

    def publish_csr_from_application_with_http_info(self, app_id, csr_id, body, **kwargs):  # noqa: E501
        """Publish Certificate Signing Request  # noqa: E501

        Updates a certificate signing request for the app with a signed X.509 certificate and adds it into the application key credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_csr_from_application_with_http_info(app_id, csr_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :param Object body: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'csr_id''body', ]  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_csr_from_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `publish_csr_from_application`")  # noqa: E501
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `publish_csr_from_application`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `publish_csr_from_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'csr_id' in params:
            path_params['csrId'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream', 'application/x-x509-ca-cert', 'application/pkix-cert', 'application/x-pem-file'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/csrs/{csrId}/lifecycle/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonWebKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_csr_from_application(self, app_id, csr_id, body, **kwargs):  # noqa: E501
        """Publish Certificate Signing Request  # noqa: E501

        Updates a certificate signing request for the app with a signed X.509 certificate and adds it into the application key credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_csr_from_application(app_id, csr_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :param Object body: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.publish_csr_from_application_with_http_info(app_id, csr_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.publish_csr_from_application_with_http_info(app_id, csr_id, body, **kwargs)  # noqa: E501
            return data

    def publish_csr_from_application_with_http_info(self, app_id, csr_id, body, **kwargs):  # noqa: E501
        """Publish Certificate Signing Request  # noqa: E501

        Updates a certificate signing request for the app with a signed X.509 certificate and adds it into the application key credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_csr_from_application_with_http_info(app_id, csr_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :param Object body: (required)
        :return: JsonWebKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'csr_id''body', ]  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_csr_from_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `publish_csr_from_application`")  # noqa: E501
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `publish_csr_from_application`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `publish_csr_from_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'csr_id' in params:
            path_params['csrId'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream', 'application/x-x509-ca-cert', 'application/pkix-cert', 'application/x-pem-file'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/csrs/{csrId}/lifecycle/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonWebKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_csr_from_application(self, app_id, csr_id, **kwargs):  # noqa: E501
        """Revoke Certificate Signing Request  # noqa: E501

        Revokes a certificate signing request and deletes the key pair from the application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_csr_from_application(app_id, csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revoke_csr_from_application_with_http_info(app_id, csr_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revoke_csr_from_application_with_http_info(app_id, csr_id, **kwargs)  # noqa: E501
            return data

    def revoke_csr_from_application_with_http_info(self, app_id, csr_id, **kwargs):  # noqa: E501
        """Revoke Certificate Signing Request  # noqa: E501

        Revokes a certificate signing request and deletes the key pair from the application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_csr_from_application_with_http_info(app_id, csr_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str csr_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'csr_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_csr_from_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `revoke_csr_from_application`")  # noqa: E501
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `revoke_csr_from_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'csr_id' in params:
            path_params['csrId'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/credentials/csrs/{csrId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_o_auth2_token_for_application(self, app_id, token_id, **kwargs):  # noqa: E501
        """revoke_o_auth2_token_for_application  # noqa: E501

        Revokes the specified token for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_o_auth2_token_for_application(app_id, token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str token_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revoke_o_auth2_token_for_application_with_http_info(app_id, token_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revoke_o_auth2_token_for_application_with_http_info(app_id, token_id, **kwargs)  # noqa: E501
            return data

    def revoke_o_auth2_token_for_application_with_http_info(self, app_id, token_id, **kwargs):  # noqa: E501
        """revoke_o_auth2_token_for_application  # noqa: E501

        Revokes the specified token for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_o_auth2_token_for_application_with_http_info(app_id, token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str token_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'token_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_o_auth2_token_for_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `revoke_o_auth2_token_for_application`")  # noqa: E501
        # verify the required parameter 'token_id' is set
        if ('token_id' not in params or
                params['token_id'] is None):
            raise ValueError("Missing the required parameter `token_id` when calling `revoke_o_auth2_token_for_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'token_id' in params:
            path_params['tokenId'] = params['token_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/tokens/{tokenId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_o_auth2_tokens_for_application(self, app_id, **kwargs):  # noqa: E501
        """revoke_o_auth2_tokens_for_application  # noqa: E501

        Revokes all tokens for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_o_auth2_tokens_for_application(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revoke_o_auth2_tokens_for_application_with_http_info(app_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revoke_o_auth2_tokens_for_application_with_http_info(app_id, **kwargs)  # noqa: E501
            return data

    def revoke_o_auth2_tokens_for_application_with_http_info(self, app_id, **kwargs):  # noqa: E501
        """revoke_o_auth2_tokens_for_application  # noqa: E501

        Revokes all tokens for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_o_auth2_tokens_for_application_with_http_info(app_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_o_auth2_tokens_for_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `revoke_o_auth2_tokens_for_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/tokens', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_scope_consent_grant(self, app_id, grant_id, **kwargs):  # noqa: E501
        """revoke_scope_consent_grant  # noqa: E501

        Revokes permission for the application to request the given scope  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_scope_consent_grant(app_id, grant_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str grant_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revoke_scope_consent_grant_with_http_info(app_id, grant_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revoke_scope_consent_grant_with_http_info(app_id, grant_id, **kwargs)  # noqa: E501
            return data

    def revoke_scope_consent_grant_with_http_info(self, app_id, grant_id, **kwargs):  # noqa: E501
        """revoke_scope_consent_grant  # noqa: E501

        Revokes permission for the application to request the given scope  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_scope_consent_grant_with_http_info(app_id, grant_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str grant_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'grant_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_scope_consent_grant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `revoke_scope_consent_grant`")  # noqa: E501
        # verify the required parameter 'grant_id' is set
        if ('grant_id' not in params or
                params['grant_id'] is None):
            raise ValueError("Missing the required parameter `grant_id` when calling `revoke_scope_consent_grant`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'grant_id' in params:
            path_params['grantId'] = params['grant_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/grants/{grantId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_application(self, app_id, body, **kwargs):  # noqa: E501
        """Update Application  # noqa: E501

        Updates an application in your organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_application(app_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param Application body: (required)
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_application_with_http_info(app_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_application_with_http_info(app_id, body, **kwargs)  # noqa: E501
            return data

    def update_application_with_http_info(self, app_id, body, **kwargs):  # noqa: E501
        """Update Application  # noqa: E501

        Updates an application in your organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_application_with_http_info(app_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param Application body: (required)
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id''body', ]  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `update_application`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_application_user(self, app_id, user_id, body, **kwargs):  # noqa: E501
        """Update Application Profile for Assigned User  # noqa: E501

        Updates a user's profile for an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_application_user(app_id, user_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str user_id: (required)
        :param AppUser body: (required)
        :return: AppUser
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_application_user_with_http_info(app_id, user_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_application_user_with_http_info(app_id, user_id, body, **kwargs)  # noqa: E501
            return data

    def update_application_user_with_http_info(self, app_id, user_id, body, **kwargs):  # noqa: E501
        """Update Application Profile for Assigned User  # noqa: E501

        Updates a user's profile for an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_application_user_with_http_info(app_id, user_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str user_id: (required)
        :param AppUser body: (required)
        :return: AppUser
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'user_id''body', ]  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_application_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `update_application_user`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_application_user`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_application_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_token']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/apps/{appId}/users/{userId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppUser',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
